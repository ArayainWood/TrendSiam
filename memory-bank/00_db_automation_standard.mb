# DB Automation Standard (TrendSiam)

**Title**: Database Automation & Schema Guard Pattern  
**Date**: 2025-10-06  
**Status**: Active Project Standard  

---

## Summary

Auto-run idempotent SQL via `psql-runner`; use Supabase Session Pooler; implement RPC schema-guard pattern with `public.util_has_column`; maintain canonical view `home_feed_v1` + alias `public_v_home_news`; support `web_view_count` column with graceful fallback; no manual SQL execution unless service-role key is unavailable.

---

## Core Components

### Connectivity
- **Standard**: Supabase Session Pooler (`SUPABASE_DB_URL` in `.env.local`)
- **Why**: Connection pooling, SSL enforcement, serverless optimization

### Tooling
- **PostgresTools LSP**: Live schema validation, IntelliSense for SQL
- **psql-runner**: Automated migration execution with dry-run, single transaction, logging

### Security
- **Plan-B Pattern**: Views + SECURITY DEFINER RPC; no base-table grants
- **Service Keys**: Environment only, never committed, redacted in logs

### Change Pattern
- **Idempotent SQL**: CREATE OR REPLACE, IF EXISTS, ON CONFLICT
- **Canonical Views**: `public.home_feed_v1` (canonical) + `public.public_v_home_news` (alias)
- **Column Support**: `web_view_count` always included; optional in frontend

---

## Schema Guard Pattern

### RPC Function
```
public.util_has_column(view_name text, col_name text) → boolean
```
- **Purpose**: Runtime column detection (PostgREST can't query info_schema directly)
- **Type**: SECURITY DEFINER, STABLE
- **Grants**: EXECUTE to anon/authenticated
- **Cache**: 5-minute TTL in API layer

### API Integration
1. Call RPC to check column existence
2. Build SELECT without missing columns
3. Post-fetch: Add missing columns in Node.js (never SQL `0 as column`)
4. Always return HTTP 200 (graceful degradation)
5. Metadata: `{ schemaGuard: { hasWebViewCount, usingFallback } }`

### Health Endpoint
- **Route**: `/api/health-schema?check=home_view`
- **Response**: `{ ok, viewName, hasWebViewCount, version }`
- **Codes**: 200 (healthy), 503 (degraded), 500 (error)

---

## Execution Workflow

### Default (Automated)
```bash
# Preflight → Dry Run → Execute → Verify
node scripts/db/psql-runner.mjs --preflight
node scripts/db/psql-runner.mjs --dry migration.sql
node scripts/db/psql-runner.mjs --exec migration.sql
node scripts/db/psql-runner.mjs --verify migration.sql
```

### Fallback (Manual)
Only when service-role key unavailable:
1. Document SQL file location
2. Execute in Supabase SQL Editor
3. Verify with health endpoint
4. Update docs

---

## Quality Gates

**Pre-Execution**:
- LSP clean (no errors)
- SQL idempotent
- Plan-B security
- Dry run passes

**Post-Execution**:
- Logs show success
- Health endpoint: `ok: true`
- Home API: HTTP 200
- Schema Guard: `usingFallback: false`
- TypeScript: clean build

---

## Frontend Integration

**Zod Schemas**: Optional columns with transforms
```typescript
web_view_count: z.union([z.number(), z.string()])
  .nullable()
  .optional()
  .transform(val => val ?? null)
```

**UI Rendering**: Nullish coalescing
```typescript
const webViews = story.webViewCount ?? 0
```

---

## Do/Don't

### ✅ DO
- Use Session Pooler URL
- Write idempotent migrations
- Use SECURITY DEFINER RPC
- Cache RPC results (5 min)
- Post-fetch fallback
- Return HTTP 200 on degradation
- Redact secrets in logs
- Run dry-run first

### ❌ DON'T
- Use direct DB host
- Grant base-table access to anon
- Query info_schema via PostgREST
- Inject `0 as column` in SELECT
- Return 500 for optional columns
- Commit service keys
- Skip dry-run
- Delete logs

---

## References

- **Full Playbook**: `docs/DB_AUTOMATION_PLAYBOOK.md`
- **Homepage Freshness**: `memory-bank/03_frontend_homepage_freshness.mb`
- **Security**: `memory-bank/01_security_plan_b.mb`
- **Testing**: `memory-bank/13_testing_acceptance_criteria.mb`

---

**Enforcement**: Mandatory for all database changes  
**Exceptions**: Require lead approval
